/// Bug Report Data Models
/// Defines structures for vulnerability reports
module suiguard::report_types {
    use std::option::{Self, Option};
    use sui::object::{Self, UID, ID};
    use sui::balance::{Self, Balance};
    use sui::sui::SUI;
    use sui::tx_context::TxContext;

    /// Vulnerability categories
    const CATEGORY_REENTRANCY: u8 = 0;
    const CATEGORY_OVERFLOW: u8 = 1;
    const CATEGORY_LOGIC_ERROR: u8 = 2;
    const CATEGORY_ACCESS_CONTROL: u8 = 3;
    const CATEGORY_PRICE_MANIPULATION: u8 = 4;
    const CATEGORY_DENIAL_OF_SERVICE: u8 = 5;
    const CATEGORY_FRONT_RUNNING: u8 = 6;
    const CATEGORY_OTHER: u8 = 7;

    /// Report status
    const STATUS_SUBMITTED: u8 = 0;
    const STATUS_UNDER_REVIEW: u8 = 1;
    const STATUS_ACCEPTED: u8 = 2;
    const STATUS_REJECTED: u8 = 3;
    const STATUS_DUPLICATE: u8 = 4;
    const STATUS_WITHDRAWN: u8 = 5;
    const STATUS_PAID: u8 = 6;

    /// Bug Report object
    /// Contains encrypted vulnerability details and metadata
    public struct BugReport has key, store {
        id: UID,
        /// ID of the bounty program this report targets
        program_id: ID,
        /// Researcher who submitted the report
        researcher: address,
        /// Severity level (0-4: Critical, High, Medium, Low, Informational)
        severity: u8,
        /// Vulnerability category
        category: u8,
        /// Walrus blob ID containing encrypted report details
        walrus_blob_id: vector<u8>,
        /// Seal policy ID for time-locked disclosure (90 days default)
        seal_policy_id: Option<vector<u8>>,
        /// Affected contract addresses/module names
        affected_targets: vector<vector<u8>>,
        /// Hash of vulnerability signature (for duplicate detection)
        vulnerability_hash: vector<u8>,
        /// Submission fee (anti-spam, refunded if valid)
        submission_fee: Balance<SUI>,
        /// Report status
        status: u8,
        /// When the report was submitted
        submitted_at: u64,
        /// When the report was last updated
        updated_at: u64,
        /// Optional: ID of duplicate report if this is marked as duplicate
        duplicate_of: Option<ID>,
        /// Optional: Attestation ID if TEE proof was provided
        attestation_id: Option<ID>,

        // === Project Response Fields ===
        /// When project acknowledged receiving the report
        acknowledged_at: Option<u64>,
        /// Whether project requested clarification
        clarification_requested: bool,
        /// Walrus blob ID for clarification message (if requested)
        clarification_message_blob: Option<vector<u8>>,
        /// Whether project disputed the severity assessment
        severity_disputed: bool,
        /// ID of triage vote created due to dispute (if any)
        dispute_triage_vote_id: Option<ID>,

        // === Fix Verification Fields ===
        /// Whether project submitted a fix
        fix_submitted: bool,
        /// Commit hash or version identifier for the fix
        fix_commit_hash: Option<vector<u8>>,
        /// New package ID if fix involved package upgrade
        fix_package_id: Option<address>,
        /// When the fix was submitted
        fix_submitted_at: Option<u64>,
        /// Whether the fix has been verified
        fix_verified: bool,
        /// When the fix was verified
        fix_verified_at: Option<u64>,
        /// Nautilus attestation ID for fix verification (if TEE verified)
        fix_verification_attestation: Option<ID>,

        // === Payout Fields ===
        /// Amount to be paid out for this report (in MIST)
        payout_amount: u64,
        /// Whether payout has been executed
        payout_executed: bool,
        /// When the payout was executed
        payout_executed_at: Option<u64>,
        /// Whether there's a pending split proposal
        has_split_proposal: bool,
        /// ID of split proposal if any
        split_proposal_id: Option<ID>,

        // === Disclosure Fields ===
        /// Timestamp when report can be publicly disclosed (90 days default)
        disclosure_deadline: u64,
        /// Whether report has been publicly disclosed
        publicly_disclosed: bool,
        /// When the report was publicly disclosed
        disclosed_at: Option<u64>,
        /// Whether project has requested early disclosure
        early_disclosure_requested: bool,
        /// When early disclosure was requested
        early_disclosure_requested_at: Option<u64>,
        /// Whether researcher has approved early disclosure
        early_disclosure_approved: bool,
        /// Updated Seal policy for public access (if disclosed)
        public_seal_policy: Option<vector<u8>>,
    }

    /// Vulnerability signature for duplicate detection
    public struct VulnerabilitySignature has store, copy, drop {
        program_id: ID,
        vulnerability_hash: vector<u8>,
    }

    // ========== Constructor (package-only) ==========

    public(package) fun new(
        program_id: ID,
        researcher: address,
        severity: u8,
        category: u8,
        walrus_blob_id: vector<u8>,
        seal_policy_id: Option<vector<u8>>,
        affected_targets: vector<vector<u8>>,
        vulnerability_hash: vector<u8>,
        submission_fee: Balance<SUI>,
        submitted_at: u64,
        ctx: &mut TxContext,
    ): BugReport {
        BugReport {
            id: object::new(ctx),
            program_id,
            researcher,
            severity,
            category,
            walrus_blob_id,
            seal_policy_id,
            affected_targets,
            vulnerability_hash,
            submission_fee,
            status: STATUS_SUBMITTED,
            submitted_at,
            updated_at: submitted_at,
            duplicate_of: option::none(),
            attestation_id: option::none(),
            // Project response fields
            acknowledged_at: option::none(),
            clarification_requested: false,
            clarification_message_blob: option::none(),
            severity_disputed: false,
            dispute_triage_vote_id: option::none(),
            // Fix verification fields
            fix_submitted: false,
            fix_commit_hash: option::none(),
            fix_package_id: option::none(),
            fix_submitted_at: option::none(),
            fix_verified: false,
            fix_verified_at: option::none(),
            fix_verification_attestation: option::none(),
            // Payout fields
            payout_amount: 0,
            payout_executed: false,
            payout_executed_at: option::none(),
            has_split_proposal: false,
            split_proposal_id: option::none(),
            // Disclosure fields (90 epochs = 90 days default)
            disclosure_deadline: submitted_at + 90,
            publicly_disclosed: false,
            disclosed_at: option::none(),
            early_disclosure_requested: false,
            early_disclosure_requested_at: option::none(),
            early_disclosure_approved: false,
            public_seal_policy: option::none(),
        }
    }

    public(package) fun new_vulnerability_signature(
        program_id: ID,
        vulnerability_hash: vector<u8>,
    ): VulnerabilitySignature {
        VulnerabilitySignature {
            program_id,
            vulnerability_hash,
        }
    }

    // ========== Getters ==========

    public fun id(report: &BugReport): &UID {
        &report.id
    }

    public fun program_id(report: &BugReport): ID {
        report.program_id
    }

    public fun researcher(report: &BugReport): address {
        report.researcher
    }

    public fun severity(report: &BugReport): u8 {
        report.severity
    }

    public fun category(report: &BugReport): u8 {
        report.category
    }

    public fun walrus_blob_id(report: &BugReport): &vector<u8> {
        &report.walrus_blob_id
    }

    public fun seal_policy_id(report: &BugReport): &Option<vector<u8>> {
        &report.seal_policy_id
    }

    public fun affected_targets(report: &BugReport): &vector<vector<u8>> {
        &report.affected_targets
    }

    public fun vulnerability_hash(report: &BugReport): &vector<u8> {
        &report.vulnerability_hash
    }

    public fun submission_fee_value(report: &BugReport): u64 {
        balance::value(&report.submission_fee)
    }

    public fun status(report: &BugReport): u8 {
        report.status
    }

    public fun submitted_at(report: &BugReport): u64 {
        report.submitted_at
    }

    public fun updated_at(report: &BugReport): u64 {
        report.updated_at
    }

    public fun duplicate_of(report: &BugReport): &Option<ID> {
        &report.duplicate_of
    }

    public fun attestation_id(report: &BugReport): &Option<ID> {
        &report.attestation_id
    }

    public fun is_submitted(report: &BugReport): bool {
        report.status == STATUS_SUBMITTED
    }

    public fun is_under_review(report: &BugReport): bool {
        report.status == STATUS_UNDER_REVIEW
    }

    public fun is_accepted(report: &BugReport): bool {
        report.status == STATUS_ACCEPTED
    }

    public fun is_rejected(report: &BugReport): bool {
        report.status == STATUS_REJECTED
    }

    public fun is_duplicate(report: &BugReport): bool {
        report.status == STATUS_DUPLICATE
    }

    public fun is_withdrawn(report: &BugReport): bool {
        report.status == STATUS_WITHDRAWN
    }

    public fun is_paid(report: &BugReport): bool {
        report.status == STATUS_PAID
    }

    // ========== VulnerabilitySignature Getters ==========

    public fun sig_program_id(sig: &VulnerabilitySignature): ID {
        sig.program_id
    }

    public fun sig_hash(sig: &VulnerabilitySignature): &vector<u8> {
        &sig.vulnerability_hash
    }

    // ========== Mutable Setters (package-only) ==========

    public(package) fun set_status(report: &mut BugReport, status: u8) {
        report.status = status;
    }

    public(package) fun set_severity(report: &mut BugReport, severity: u8) {
        report.severity = severity;
    }

    public(package) fun set_updated_at(report: &mut BugReport, timestamp: u64) {
        report.updated_at = timestamp;
    }

    public(package) fun set_duplicate_of(report: &mut BugReport, original_id: ID) {
        report.duplicate_of = option::some(original_id);
    }

    public(package) fun set_attestation_id(report: &mut BugReport, attestation_id: ID) {
        report.attestation_id = option::some(attestation_id);
    }

    // === Project Response Setters ===

    public(package) fun acknowledge_report_internal(report: &mut BugReport, timestamp: u64) {
        report.acknowledged_at = option::some(timestamp);
        report.updated_at = timestamp;
    }

    public(package) fun request_clarification_internal(
        report: &mut BugReport,
        message_blob: vector<u8>,
        timestamp: u64,
    ) {
        report.clarification_requested = true;
        report.clarification_message_blob = option::some(message_blob);
        report.updated_at = timestamp;
    }

    public(package) fun dispute_severity_internal(
        report: &mut BugReport,
        triage_vote_id: ID,
        timestamp: u64,
    ) {
        report.severity_disputed = true;
        report.dispute_triage_vote_id = option::some(triage_vote_id);
        report.updated_at = timestamp;
    }

    // === Fix Verification Setters ===

    public(package) fun submit_fix_internal(
        report: &mut BugReport,
        commit_hash: Option<vector<u8>>,
        package_id: Option<address>,
        timestamp: u64,
    ) {
        report.fix_submitted = true;
        report.fix_commit_hash = commit_hash;
        report.fix_package_id = package_id;
        report.fix_submitted_at = option::some(timestamp);
        report.updated_at = timestamp;
    }

    public(package) fun verify_fix_internal(
        report: &mut BugReport,
        attestation_id: Option<ID>,
        timestamp: u64,
    ) {
        report.fix_verified = true;
        report.fix_verified_at = option::some(timestamp);
        report.fix_verification_attestation = attestation_id;
        report.updated_at = timestamp;
    }

    // === Getters for new fields ===

    public fun acknowledged_at(report: &BugReport): Option<u64> {
        report.acknowledged_at
    }

    public fun clarification_requested(report: &BugReport): bool {
        report.clarification_requested
    }

    public fun clarification_message_blob(report: &BugReport): Option<vector<u8>> {
        report.clarification_message_blob
    }

    public fun severity_disputed(report: &BugReport): bool {
        report.severity_disputed
    }

    public fun dispute_triage_vote_id(report: &BugReport): Option<ID> {
        report.dispute_triage_vote_id
    }

    public fun fix_submitted(report: &BugReport): bool {
        report.fix_submitted
    }

    public fun fix_commit_hash(report: &BugReport): Option<vector<u8>> {
        report.fix_commit_hash
    }

    public fun fix_package_id(report: &BugReport): Option<address> {
        report.fix_package_id
    }

    public fun fix_submitted_at(report: &BugReport): Option<u64> {
        report.fix_submitted_at
    }

    public fun fix_verified(report: &BugReport): bool {
        report.fix_verified
    }

    public fun fix_verified_at(report: &BugReport): Option<u64> {
        report.fix_verified_at
    }

    public fun fix_verification_attestation(report: &BugReport): Option<ID> {
        report.fix_verification_attestation
    }

    // === Payout Field Getters ===

    public fun payout_amount(report: &BugReport): u64 {
        report.payout_amount
    }

    public fun payout_executed(report: &BugReport): bool {
        report.payout_executed
    }

    public fun payout_executed_at(report: &BugReport): Option<u64> {
        report.payout_executed_at
    }

    public fun has_split_proposal(report: &BugReport): bool {
        report.has_split_proposal
    }

    public fun split_proposal_id(report: &BugReport): Option<ID> {
        report.split_proposal_id
    }

    // === Payout Field Setters ===

    public(package) fun set_payout_amount(report: &mut BugReport, amount: u64) {
        report.payout_amount = amount;
    }

    public(package) fun execute_payout_internal(report: &mut BugReport, timestamp: u64) {
        report.payout_executed = true;
        report.payout_executed_at = option::some(timestamp);
        report.updated_at = timestamp;
    }

    public(package) fun set_split_proposal(report: &mut BugReport, proposal_id: ID) {
        report.has_split_proposal = true;
        report.split_proposal_id = option::some(proposal_id);
    }

    public(package) fun clear_split_proposal(report: &mut BugReport) {
        report.has_split_proposal = false;
        report.split_proposal_id = option::none();
    }

    public(package) fun withdraw_fee(report: &mut BugReport): Balance<SUI> {
        let fee_amount = balance::value(&report.submission_fee);
        balance::split(&mut report.submission_fee, fee_amount)
    }

    // === Disclosure Field Getters ===

    public fun disclosure_deadline(report: &BugReport): u64 {
        report.disclosure_deadline
    }

    public fun publicly_disclosed(report: &BugReport): bool {
        report.publicly_disclosed
    }

    public fun disclosed_at(report: &BugReport): Option<u64> {
        report.disclosed_at
    }

    public fun early_disclosure_requested(report: &BugReport): bool {
        report.early_disclosure_requested
    }

    public fun early_disclosure_requested_at(report: &BugReport): Option<u64> {
        report.early_disclosure_requested_at
    }

    public fun early_disclosure_approved(report: &BugReport): bool {
        report.early_disclosure_approved
    }

    public fun public_seal_policy(report: &BugReport): Option<vector<u8>> {
        report.public_seal_policy
    }

    // === Disclosure Field Setters ===

    public(package) fun request_early_disclosure_internal(report: &mut BugReport, timestamp: u64) {
        report.early_disclosure_requested = true;
        report.early_disclosure_requested_at = option::some(timestamp);
        report.updated_at = timestamp;
    }

    public(package) fun approve_early_disclosure_internal(report: &mut BugReport) {
        report.early_disclosure_approved = true;
    }

    public(package) fun trigger_disclosure_internal(
        report: &mut BugReport,
        public_seal_policy: vector<u8>,
        timestamp: u64,
    ) {
        report.publicly_disclosed = true;
        report.disclosed_at = option::some(timestamp);
        report.public_seal_policy = option::some(public_seal_policy);
        report.updated_at = timestamp;
    }

    public(package) fun destroy_empty(report: BugReport) {
        let BugReport {
            id,
            program_id: _,
            researcher: _,
            severity: _,
            category: _,
            walrus_blob_id: _,
            seal_policy_id: _,
            affected_targets: _,
            vulnerability_hash: _,
            submission_fee,
            status: _,
            submitted_at: _,
            updated_at: _,
            duplicate_of: _,
            attestation_id: _,
            acknowledged_at: _,
            clarification_requested: _,
            clarification_message_blob: _,
            severity_disputed: _,
            dispute_triage_vote_id: _,
            fix_submitted: _,
            fix_commit_hash: _,
            fix_package_id: _,
            fix_submitted_at: _,
            fix_verified: _,
            fix_verified_at: _,
            fix_verification_attestation: _,
            payout_amount: _,
            payout_executed: _,
            payout_executed_at: _,
            has_split_proposal: _,
            split_proposal_id: _,
            disclosure_deadline: _,
            publicly_disclosed: _,
            disclosed_at: _,
            early_disclosure_requested: _,
            early_disclosure_requested_at: _,
            early_disclosure_approved: _,
            public_seal_policy: _,
        } = report;

        balance::destroy_zero(submission_fee);
        object::delete(id);
    }

    // ========== Constants ==========

    public fun category_reentrancy(): u8 { CATEGORY_REENTRANCY }
    public fun category_overflow(): u8 { CATEGORY_OVERFLOW }
    public fun category_logic_error(): u8 { CATEGORY_LOGIC_ERROR }
    public fun category_access_control(): u8 { CATEGORY_ACCESS_CONTROL }
    public fun category_price_manipulation(): u8 { CATEGORY_PRICE_MANIPULATION }
    public fun category_denial_of_service(): u8 { CATEGORY_DENIAL_OF_SERVICE }
    public fun category_front_running(): u8 { CATEGORY_FRONT_RUNNING }
    public fun category_other(): u8 { CATEGORY_OTHER }

    public fun status_submitted(): u8 { STATUS_SUBMITTED }
    public fun status_under_review(): u8 { STATUS_UNDER_REVIEW }
    public fun status_accepted(): u8 { STATUS_ACCEPTED }
    public fun status_rejected(): u8 { STATUS_REJECTED }
    public fun status_duplicate(): u8 { STATUS_DUPLICATE }
    public fun status_withdrawn(): u8 { STATUS_WITHDRAWN }
    public fun status_paid(): u8 { STATUS_PAID }
}
