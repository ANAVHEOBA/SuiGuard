// Copyright (c) SuiGuard, Inc.
// SPDX-License-Identifier: MIT

/// Vulnerability Archive Types
/// Permanent storage and indexing of finalized bug reports
module suiguard::archive_types {
    use std::option::{Self, Option};
    use sui::object::{Self, UID, ID};
    use sui::tx_context::TxContext;
    use sui::vec_set::{Self, VecSet};
    use sui::table::{Self, Table};

    /// CWE (Common Weakness Enumeration) Classifications
    /// Reference: https://cwe.mitre.org/
    const CWE_REENTRANCY: u16 = 841;              // CWE-841: Improper Enforcement of Behavioral Workflow
    const CWE_INTEGER_OVERFLOW: u16 = 190;        // CWE-190: Integer Overflow or Wraparound
    const CWE_ACCESS_CONTROL: u16 = 284;          // CWE-284: Improper Access Control
    const CWE_LOGIC_ERROR: u16 = 840;             // CWE-840: Business Logic Errors
    const CWE_PRICE_MANIPULATION: u16 = 829;      // CWE-829: Inclusion of Functionality from Untrusted Control Sphere
    const CWE_DOS: u16 = 400;                     // CWE-400: Uncontrolled Resource Consumption
    const CWE_FRONT_RUNNING: u16 = 362;           // CWE-362: Concurrent Execution using Shared Resource
    const CWE_UNCHECKED_RETURN: u16 = 252;        // CWE-252: Unchecked Return Value
    const CWE_UNINITIALIZED: u16 = 457;           // CWE-457: Use of Uninitialized Variable
    const CWE_TYPE_CONFUSION: u16 = 843;          // CWE-843: Access of Resource Using Incompatible Type

    /// Archived vulnerability report
    /// Immutable snapshot of a finalized bug report
    public struct ArchivedReport has key, store {
        id: UID,
        /// Original report ID
        report_id: ID,
        /// Program that was affected
        program_id: ID,
        /// Name of the affected program
        program_name: vector<u8>,
        /// Researcher who found the bug
        researcher: address,
        /// Severity (0-4: Critical, High, Medium, Low, Informational)
        severity: u8,
        /// CWE classification
        cwe_id: u16,
        /// Walrus blob ID containing full report
        walrus_blob_id: vector<u8>,
        /// Public Seal policy (after disclosure)
        public_seal_policy: vector<u8>,
        /// Affected Move modules/packages
        affected_modules: vector<vector<u8>>,
        /// Affected functions
        affected_functions: vector<vector<u8>>,
        /// Vulnerability fingerprint (for pattern matching)
        vulnerability_fingerprint: vector<u8>,
        /// Related bug report IDs (similar patterns)
        related_bugs: VecSet<ID>,
        /// Payout amount (in MIST)
        payout_amount: u64,
        /// When report was submitted
        submitted_at: u64,
        /// When report was disclosed
        disclosed_at: u64,
        /// When report was archived
        archived_at: u64,
        /// Fix commit hash (if available)
        fix_commit_hash: Option<vector<u8>>,
        /// Fixed package ID (if available)
        fix_package_id: Option<address>,
    }

    /// Vulnerability Archive Registry
    /// Shared object for indexing all archived reports
    public struct ArchiveRegistry has key {
        id: UID,
        /// Total number of archived reports
        total_reports: u64,
        /// Index by CWE type
        cwe_index: Table<u16, VecSet<ID>>,
        /// Index by affected program
        program_index: Table<ID, VecSet<ID>>,
        /// Index by severity
        severity_index: Table<u8, VecSet<ID>>,
        /// Index by researcher
        researcher_index: Table<address, VecSet<ID>>,
        /// Vulnerability fingerprint index (for pattern matching)
        fingerprint_index: Table<vector<u8>, VecSet<ID>>,
        /// Total payouts distributed (statistics)
        total_payouts: u64,
        /// Reports by CWE type (statistics)
        cwe_statistics: Table<u16, u64>,
    }

    /// Vulnerability Pattern
    /// Generated by ML analysis (off-chain) and stored on-chain
    public struct VulnerabilityPattern has key, store {
        id: UID,
        /// Pattern fingerprint
        fingerprint: vector<u8>,
        /// CWE classification
        cwe_id: u16,
        /// Pattern description
        description: vector<u8>,
        /// Affected code patterns (regex or signature)
        code_patterns: vector<vector<u8>>,
        /// Number of reports matching this pattern
        occurrence_count: u64,
        /// Report IDs matching this pattern
        matching_reports: VecSet<ID>,
        /// When pattern was identified
        identified_at: u64,
        /// Last updated timestamp
        updated_at: u64,
    }

    // ========== Constructor Functions ==========

    /// Create a new archive registry
    public(package) fun new_registry(ctx: &mut TxContext): ArchiveRegistry {
        ArchiveRegistry {
            id: object::new(ctx),
            total_reports: 0,
            cwe_index: table::new(ctx),
            program_index: table::new(ctx),
            severity_index: table::new(ctx),
            researcher_index: table::new(ctx),
            fingerprint_index: table::new(ctx),
            total_payouts: 0,
            cwe_statistics: table::new(ctx),
        }
    }

    /// Create a new archived report
    public(package) fun new_archived_report(
        report_id: ID,
        program_id: ID,
        program_name: vector<u8>,
        researcher: address,
        severity: u8,
        cwe_id: u16,
        walrus_blob_id: vector<u8>,
        public_seal_policy: vector<u8>,
        affected_modules: vector<vector<u8>>,
        affected_functions: vector<vector<u8>>,
        vulnerability_fingerprint: vector<u8>,
        payout_amount: u64,
        submitted_at: u64,
        disclosed_at: u64,
        archived_at: u64,
        fix_commit_hash: Option<vector<u8>>,
        fix_package_id: Option<address>,
        ctx: &mut TxContext,
    ): ArchivedReport {
        ArchivedReport {
            id: object::new(ctx),
            report_id,
            program_id,
            program_name,
            researcher,
            severity,
            cwe_id,
            walrus_blob_id,
            public_seal_policy,
            affected_modules,
            affected_functions,
            vulnerability_fingerprint,
            related_bugs: vec_set::empty(),
            payout_amount,
            submitted_at,
            disclosed_at,
            archived_at,
            fix_commit_hash,
            fix_package_id,
        }
    }

    /// Create a new vulnerability pattern
    public(package) fun new_vulnerability_pattern(
        fingerprint: vector<u8>,
        cwe_id: u16,
        description: vector<u8>,
        code_patterns: vector<vector<u8>>,
        identified_at: u64,
        ctx: &mut TxContext,
    ): VulnerabilityPattern {
        VulnerabilityPattern {
            id: object::new(ctx),
            fingerprint,
            cwe_id,
            description,
            code_patterns,
            occurrence_count: 0,
            matching_reports: vec_set::empty(),
            identified_at,
            updated_at: identified_at,
        }
    }

    // ========== Getters: ArchiveRegistry ==========

    public fun registry_id(registry: &ArchiveRegistry): &UID {
        &registry.id
    }

    public fun total_reports(registry: &ArchiveRegistry): u64 {
        registry.total_reports
    }

    public fun total_payouts(registry: &ArchiveRegistry): u64 {
        registry.total_payouts
    }

    public fun cwe_index(registry: &ArchiveRegistry): &Table<u16, VecSet<ID>> {
        &registry.cwe_index
    }

    public fun program_index(registry: &ArchiveRegistry): &Table<ID, VecSet<ID>> {
        &registry.program_index
    }

    public fun severity_index(registry: &ArchiveRegistry): &Table<u8, VecSet<ID>> {
        &registry.severity_index
    }

    public fun researcher_index(registry: &ArchiveRegistry): &Table<address, VecSet<ID>> {
        &registry.researcher_index
    }

    public fun fingerprint_index(registry: &ArchiveRegistry): &Table<vector<u8>, VecSet<ID>> {
        &registry.fingerprint_index
    }

    public fun cwe_statistics(registry: &ArchiveRegistry): &Table<u16, u64> {
        &registry.cwe_statistics
    }

    // ========== Getters: ArchivedReport ==========

    public fun archived_report_id(report: &ArchivedReport): &UID {
        &report.id
    }

    public fun original_report_id(report: &ArchivedReport): ID {
        report.report_id
    }

    public fun archived_program_id(report: &ArchivedReport): ID {
        report.program_id
    }

    public fun program_name(report: &ArchivedReport): &vector<u8> {
        &report.program_name
    }

    public fun archived_researcher(report: &ArchivedReport): address {
        report.researcher
    }

    public fun archived_severity(report: &ArchivedReport): u8 {
        report.severity
    }

    public fun cwe_id(report: &ArchivedReport): u16 {
        report.cwe_id
    }

    public fun archived_walrus_blob_id(report: &ArchivedReport): &vector<u8> {
        &report.walrus_blob_id
    }

    public fun archived_public_seal_policy(report: &ArchivedReport): &vector<u8> {
        &report.public_seal_policy
    }

    public fun affected_modules(report: &ArchivedReport): &vector<vector<u8>> {
        &report.affected_modules
    }

    public fun affected_functions(report: &ArchivedReport): &vector<vector<u8>> {
        &report.affected_functions
    }

    public fun vulnerability_fingerprint(report: &ArchivedReport): &vector<u8> {
        &report.vulnerability_fingerprint
    }

    public fun related_bugs(report: &ArchivedReport): &VecSet<ID> {
        &report.related_bugs
    }

    public fun archived_payout_amount(report: &ArchivedReport): u64 {
        report.payout_amount
    }

    public fun archived_submitted_at(report: &ArchivedReport): u64 {
        report.submitted_at
    }

    public fun archived_disclosed_at(report: &ArchivedReport): u64 {
        report.disclosed_at
    }

    public fun archived_at(report: &ArchivedReport): u64 {
        report.archived_at
    }

    public fun fix_commit_hash(report: &ArchivedReport): Option<vector<u8>> {
        report.fix_commit_hash
    }

    public fun fix_package_id(report: &ArchivedReport): Option<address> {
        report.fix_package_id
    }

    // ========== Getters: VulnerabilityPattern ==========

    public fun pattern_id(pattern: &VulnerabilityPattern): &UID {
        &pattern.id
    }

    public fun pattern_fingerprint(pattern: &VulnerabilityPattern): &vector<u8> {
        &pattern.fingerprint
    }

    public fun pattern_cwe_id(pattern: &VulnerabilityPattern): u16 {
        pattern.cwe_id
    }

    public fun pattern_description(pattern: &VulnerabilityPattern): &vector<u8> {
        &pattern.description
    }

    public fun code_patterns(pattern: &VulnerabilityPattern): &vector<vector<u8>> {
        &pattern.code_patterns
    }

    public fun occurrence_count(pattern: &VulnerabilityPattern): u64 {
        pattern.occurrence_count
    }

    public fun matching_reports(pattern: &VulnerabilityPattern): &VecSet<ID> {
        &pattern.matching_reports
    }

    // ========== Mutable Functions (package-only) ==========

    /// Add report to registry indices
    public(package) fun index_archived_report(
        registry: &mut ArchiveRegistry,
        archived_id: ID,
        program_id: ID,
        severity: u8,
        cwe_id: u16,
        researcher: address,
        fingerprint: vector<u8>,
        payout_amount: u64,
    ) {
        registry.total_reports = registry.total_reports + 1;
        registry.total_payouts = registry.total_payouts + payout_amount;

        // Index by CWE
        if (!table::contains(&registry.cwe_index, cwe_id)) {
            table::add(&mut registry.cwe_index, cwe_id, vec_set::empty());
        };
        let cwe_set = table::borrow_mut(&mut registry.cwe_index, cwe_id);
        vec_set::insert(cwe_set, archived_id);

        // Update CWE statistics
        if (!table::contains(&registry.cwe_statistics, cwe_id)) {
            table::add(&mut registry.cwe_statistics, cwe_id, 0);
        };
        let count = table::borrow_mut(&mut registry.cwe_statistics, cwe_id);
        *count = *count + 1;

        // Index by program
        if (!table::contains(&registry.program_index, program_id)) {
            table::add(&mut registry.program_index, program_id, vec_set::empty());
        };
        let program_set = table::borrow_mut(&mut registry.program_index, program_id);
        vec_set::insert(program_set, archived_id);

        // Index by severity
        if (!table::contains(&registry.severity_index, severity)) {
            table::add(&mut registry.severity_index, severity, vec_set::empty());
        };
        let severity_set = table::borrow_mut(&mut registry.severity_index, severity);
        vec_set::insert(severity_set, archived_id);

        // Index by researcher
        if (!table::contains(&registry.researcher_index, researcher)) {
            table::add(&mut registry.researcher_index, researcher, vec_set::empty());
        };
        let researcher_set = table::borrow_mut(&mut registry.researcher_index, researcher);
        vec_set::insert(researcher_set, archived_id);

        // Index by fingerprint
        if (!table::contains(&registry.fingerprint_index, fingerprint)) {
            table::add(&mut registry.fingerprint_index, fingerprint, vec_set::empty());
        };
        let fingerprint_set = table::borrow_mut(&mut registry.fingerprint_index, fingerprint);
        vec_set::insert(fingerprint_set, archived_id);
    }

    /// Link related bugs
    public(package) fun add_related_bug(report: &mut ArchivedReport, related_id: ID) {
        vec_set::insert(&mut report.related_bugs, related_id);
    }

    /// Add report to vulnerability pattern
    public(package) fun add_report_to_pattern(
        pattern: &mut VulnerabilityPattern,
        report_id: ID,
        timestamp: u64,
    ) {
        vec_set::insert(&mut pattern.matching_reports, report_id);
        pattern.occurrence_count = pattern.occurrence_count + 1;
        pattern.updated_at = timestamp;
    }

    // ========== CWE Classification Helpers ==========

    /// Map category to CWE ID
    public fun category_to_cwe(category: u8): u16 {
        if (category == 0) { CWE_REENTRANCY }
        else if (category == 1) { CWE_INTEGER_OVERFLOW }
        else if (category == 2) { CWE_LOGIC_ERROR }
        else if (category == 3) { CWE_ACCESS_CONTROL }
        else if (category == 4) { CWE_PRICE_MANIPULATION }
        else if (category == 5) { CWE_DOS }
        else if (category == 6) { CWE_FRONT_RUNNING }
        else { CWE_LOGIC_ERROR } // Default to logic error
    }

    /// Get CWE name
    public fun get_cwe_name(cwe_id: u16): vector<u8> {
        if (cwe_id == CWE_REENTRANCY) { b"Improper Enforcement of Behavioral Workflow" }
        else if (cwe_id == CWE_INTEGER_OVERFLOW) { b"Integer Overflow or Wraparound" }
        else if (cwe_id == CWE_ACCESS_CONTROL) { b"Improper Access Control" }
        else if (cwe_id == CWE_LOGIC_ERROR) { b"Business Logic Errors" }
        else if (cwe_id == CWE_PRICE_MANIPULATION) { b"Inclusion of Functionality from Untrusted Control Sphere" }
        else if (cwe_id == CWE_DOS) { b"Uncontrolled Resource Consumption" }
        else if (cwe_id == CWE_FRONT_RUNNING) { b"Concurrent Execution using Shared Resource" }
        else if (cwe_id == CWE_UNCHECKED_RETURN) { b"Unchecked Return Value" }
        else if (cwe_id == CWE_UNINITIALIZED) { b"Use of Uninitialized Variable" }
        else if (cwe_id == CWE_TYPE_CONFUSION) { b"Access of Resource Using Incompatible Type" }
        else { b"Unknown CWE" }
    }

    // ========== Constants ==========

    public fun cwe_reentrancy(): u16 { CWE_REENTRANCY }
    public fun cwe_integer_overflow(): u16 { CWE_INTEGER_OVERFLOW }
    public fun cwe_access_control(): u16 { CWE_ACCESS_CONTROL }
    public fun cwe_logic_error(): u16 { CWE_LOGIC_ERROR }
    public fun cwe_price_manipulation(): u16 { CWE_PRICE_MANIPULATION }
    public fun cwe_dos(): u16 { CWE_DOS }
    public fun cwe_front_running(): u16 { CWE_FRONT_RUNNING }
    public fun cwe_unchecked_return(): u16 { CWE_UNCHECKED_RETURN }
    public fun cwe_uninitialized(): u16 { CWE_UNINITIALIZED }
    public fun cwe_type_confusion(): u16 { CWE_TYPE_CONFUSION }

    // ========== Share Functions ==========

    /// Share registry as public object
    public(package) fun share_registry(registry: ArchiveRegistry) {
        use sui::transfer;
        transfer::share_object(registry);
    }
}
